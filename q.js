class D{max;get parallelize(){return this.p}set parallelize(q){let j=q-this.p;this.p=q;while(j-- >0)setTimeout(()=>this.n())}p=1;q=0;r=0;c;d;constructor({max:q=Number.MAX_SAFE_INTEGER,parallelize:j=1}={}){this.max=q,this.p=j,this.n()}get queued(){return this.q}get running(){return this.r}add(q,j){if(this.q>=this.max)return null;if(typeof j==="function")j={listener:j};let w=this.i(q,j);return(async()=>{let y;for await(let[A,B]of w)if(A!==null)j?.listener?.(A);else y=B;return y})()}iterate(q,j){return this.q>=this.max?null:this.i(q,j)}async*i(q,{signal:j}={}){let w,y=this.p>this.r?0:++this.q,A=j&&new Promise((B,C)=>j.addEventListener("abort",()=>C(j.reason)));try{if(y>0){while(y>0)if(yield[y],await(A?Promise.race([A,this.d]):this.d),this.p>=this.r)y--;this.q--}if(w=q(),this.r++,yield[0],w&&typeof w==="object"&&Symbol.asyncIterator in w)for await(let B of w)yield[null,B];else yield[null,await w]}finally{if(y>0)this.q--;if(w)this.r--;this.n()}}n(){return this.c?.(),this.d=new Promise((q)=>this.c=q)}}export{D as Queue};
